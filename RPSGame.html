<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>8√ó8 RPS ‚Äî 4 Q-Learners (Prelaunch Preview + Meta Trend)</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f1730; --ink:#e8eefc; --muted:#a9b7ff;
    --grid:#1b2547; --cell:#0f1730; --item:#0e223f;
    --red:#ff6b6b; --blue:#4dabf7; --green:#51cf66; --yellow:#ffd43b;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{display:grid; grid-template-columns:minmax(300px, 360px) 1fr; height:100vh}
  aside{background:var(--panel); border-right:1px solid #0d1430; padding:14px; display:flex; flex-direction:column; gap:12px}
  h1{font-size:16px;margin:0 0 4px 0}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  button{background:#1f2a4d;color:var(--ink);border:1px solid #2b3b78;border-radius:10px;padding:10px 12px;cursor:pointer}
  button:disabled{opacity:.6; cursor:not-allowed}
  input[type="range"]{width:160px}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:999px;background:#141e3d;border:1px solid #2b3b78}
  .chip{width:12px;height:12px;border-radius:3px}
  .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .card{background:#0e1633;border:1px solid #20306a;border-radius:12px;padding:10px}
  #boardWrap{display:grid; place-items:center; padding:12px}
  #board{
    position:relative; /* enable absolute-positioned agents */
    width:min(92vmin, 80vh); aspect-ratio:1/1;
    display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr);
    gap:2px; background:var(--grid); border:1px solid #263571; border-radius:12px; padding:2px;
  }
  .cell{ background:var(--cell); position:relative; border-radius:6px; display:grid; place-items:center; font-size:20px; user-select:none; }
  .owner::after{ content:""; position:absolute; inset:0; border-radius:6px; opacity:.25; }
  .owner.red::after{background:var(--red)}
  .owner.blue::after{background:var(--blue)}
  .owner.green::after{background:var(--green)}
  .owner.yellow::after{background:var(--yellow)}
  .agent{ position:absolute; display:grid; place-items:center; font-size:22px; line-height:1; border:2px solid #ffffff22; box-shadow:0 2px 6px #0006; border-radius:50%; pointer-events:none;
    transition: left 140ms linear, top 140ms linear; /* smooth slide */ }
  .agent.red{background:var(--red)}
  .agent.blue{background:var(--blue)}
  .agent.green{background:var(--green)}
  .agent.yellow{background:var(--yellow)}
  .ground{ position:absolute; left:4px; top:2px; font-size:18px; opacity:.95; filter:drop-shadow(0 1px 0 #0007); }
  #log{ max-height:24vh; overflow:auto; margin-top:-4px; background:#0e1633;border:1px solid #20306a;border-radius:12px;padding:8px 10px;font-size:13px }
  #log .line{opacity:.95; margin:4px 0}
  @media (max-width: 820px){ #wrap{grid-template-columns:1fr; grid-template-rows:auto 1fr} aside{border-right:none; border-bottom:1px solid #0d1430} #log{max-height:20vh} }
</style>
</head>
<body>
<div id="wrap">
  <aside>
    <h1>8√ó8 Rock ‚Ä¢ Paper ‚Ä¢ Scissors ‚Äî 4 Q‚ÄëLearners</h1>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="resetBtn">New Map</button>
      <label class="badge" style="gap:6px"><input id="autoNext" type="checkbox"/> Auto Next</label>
    </div>
    <div class="row">
      <span class="badge">Speed: <span id="speedVal">1</span> steps/sec</span>
      <input id="speed" type="range" min="1" max="20" step="1" value="1" />
      <span class="badge">Œµ: <span id="epsVal">0.15</span></span>
      <input id="eps" type="range" min="0" max="1" step="0.01" value="0.15" />
    </div>

    <div class="card stats">
      <div><div class="badge"><span class="chip" style="background:var(--red)"></span> Red tiles: <b id="redCount">0</b></div></div>
      <div><div class="badge"><span class="chip" style="background:var(--blue)"></span> Blue tiles: <b id="blueCount">0</b></div></div>
      <div><div class="badge"><span class="chip" style="background:var(--green)"></span> Green tiles: <b id="greenCount">0</b></div></div>
      <div><div class="badge"><span class="chip" style="background:var(--yellow)"></span> Yellow tiles: <b id="yellowCount">0</b></div></div>
    </div>

    <div class="card">
      <div class="row" style="gap:12px">
        <span class="badge">üéØ Win: 40 tiles (‚â•40) or last standing</span>
        <span class="badge">üéì Games: <b id="games">0</b></span>
      </div>
      <div class="row" style="gap:12px; margin-top:8px">
        <span class="badge">üèÜ Wins ‚Äî R:<b id="wR">0</b> P:<b id="wP">0</b> S:<b id="wS">0</b></span>
        <span class="badge">Trend bonus per item is proportional to these wins.</span>
      </div>
      <div class="row" style="gap:12px; margin-top:6px">
        <span class="badge">ü•á Color wins ‚Äî
          <span class="chip" style="background:var(--red)"></span><b id="cwRed">0</b>
          <span class="chip" style="background:var(--blue)"></span><b id="cwBlue">0</b>
          <span class="chip" style="background:var(--green)"></span><b id="cwGreen">0</b>
          <span class="chip" style="background:var(--yellow)"></span><b id="cwYellow">0</b>
        </span>
      </div>
      <div style="margin-top:8px; opacity:.85">
        Before starting, you already see the four agents parked in the corners. During play they move randomly but learn across games which ground item to pick (or skip) based on rewards from victories and from painting new tiles.
      </div>
    </div>

    <div id="log" class="card" aria-live="polite" aria-label="game log"></div>
  </aside>

  <div id="boardWrap">
    <div id="board" aria-label="8x8 board"></div>
  </div>
</div>

<script>
(() => {
  // ======= Config =======
  const N = 8;
  const ITEMS_PER = 5; // 5 of each = 15 total
  const CLAIM_TO_WIN = 40; // 50% of 64
  const STEP_REWARD_NEW_TILE = 0.02; // encourages covering ground
  const WIN_REWARD_TILES = 2.0;      // win by tiles
  const WIN_REWARD_LAST = 2.0;       // win by last standing
  const LOSS_REWARD = -1.0;          // optional penalty for losing
  const GAMMA = 0.9;
  let ALPHA = 0.25;
  let EPSILON = 0.15;

  const EMOJI = { rock:"ü™®", paper:"üìÑ", scissors:"‚úÇÔ∏è" };
  const COLORS = ["red","blue","green","yellow"];
  const CORNERS = [{x:0,y:0},{x:0,y:N-1},{x:N-1,y:0},{x:N-1,y:N-1}];
  const ITEM_LIST = ["rock","paper","scissors"];
  const PICK_ACTIONS = ["pick","skip"];

  // ======= State =======
  let boardEl, cells = [];
  let ownership;
  let ground;
  let agents;
  let agentEls = new Map();
  let cellCenters = [];
  let agentPx = 0; // size in px
  let running = false;
  let stepTimer = null;
  let stepsPerSec = 1;
  let gameCount = 0;
  let winsByItem = { rock:0, paper:0, scissors:0 };
  let winsByColor = { red:0, blue:0, green:0, yellow:0 };
  let gameOver = true; // true when not actively running a round
  let stepCount = 0; // step counter for pacing
  let spawnIn = 0;   // countdown (steps) until next item spawn [20..30]

  // ======= Test harness (non-invasive) =======
  window.__t = { resets:0, starts:0 };

  function newQ(){
    const q = {};
    for (const s of ITEM_LIST){ q[s] = { pick: 0, skip: 0 }; }
    return q;
  }
  function newEpisode(){ return { pickups: [], stepCoverReward: 0, survived:true, win:false, winBy:"" }; }

  const qs = s => document.querySelector(s);
  const startBtn = qs("#startBtn");
  const pauseBtn = qs("#pauseBtn");
  const resetBtn = qs("#resetBtn");
  const autoNext = qs("#autoNext");
  const speed = qs("#speed");
  const speedVal = qs("#speedVal");
  const eps = qs("#eps");
  const epsVal = qs("#epsVal");
  const redCountEl = qs("#redCount");
  const blueCountEl = qs("#blueCount");
  const greenCountEl = qs("#greenCount");
  const yellowCountEl = qs("#yellowCount");
  const gamesEl = qs("#games");
  const wR = qs("#wR");
  const wP = qs("#wP");
  const wS = qs("#wS");
  const cwRed = qs("#cwRed"), cwBlue = qs("#cwBlue"), cwGreen = qs("#cwGreen"), cwYellow = qs("#cwYellow");
  const logBox = qs("#log");

  const inBounds = (x,y)=> x>=0 && x<N && y>=0 && y<N;
  const key = (x,y)=> `${x},${y}`;
  const shuffle = arr => { for(let i=arr.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; };
  function log(msg){ const line = document.createElement("div"); line.className = "line"; line.textContent = msg; logBox.prepend(line); while (logBox.children.length > 80) logBox.lastChild.remove(); }

  // Standard RPS: rock > scissors, scissors > paper, paper > rock
  function rpsWinner(aItem, bItem){
    // Handle empties (an item beats empty)
    if (!aItem && !bItem) return 0;
    if (aItem && !bItem) return 1;
    if (!aItem && bItem) return -1;
    // Same item draws
    if (aItem === bItem) return 0;
    // Canonical relations
    if (aItem === 'rock'     && bItem === 'scissors') return 1;
    if (aItem === 'scissors' && bItem === 'paper')    return 1;
    if (aItem === 'paper'    && bItem === 'rock')     return 1;
    return -1;
  }

  function buildBoard(){
    boardEl = qs("#board");
    boardEl.innerHTML = "";
    cells = [];
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        const c = document.createElement("div");
        c.className = "cell";
        c.dataset.x = x; c.dataset.y = y;
        boardEl.appendChild(c);
        cells.push(c);
      }
    }
  }
  function cellEl(x,y){ return cells[y*N + x]; }

  function cacheLayout(){
    cellCenters = Array.from({length:N},()=>Array(N).fill([0,0]));
    const boardRect = boardEl.getBoundingClientRect();
    const c0 = cellEl(0,0).getBoundingClientRect();
    agentPx = Math.round(c0.width * 0.7);
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        const r = cellEl(x,y).getBoundingClientRect();
        const cx = (r.left - boardRect.left) + r.width/2;
        const cy = (r.top - boardRect.top) + r.height/2;
        cellCenters[y][x] = [cx, cy];
      }
    }
    // update sizes on existing agents
    agentEls.forEach(el=>{ el.style.width = agentPx+"px"; el.style.height = agentPx+"px"; });
  }
  window.addEventListener('resize', () => { cacheLayout(); updateAgentPositions(); });

  function clearOverlays(){ for (const c of cells){ c.className = "cell"; c.replaceChildren(); } }

  function initEmpty(){
    ownership = Array.from({length:N}, _ => Array(N).fill(null));
    ground = Array.from({length:N}, _ => Array(N).fill(null));
    agents = [];
    clearOverlays();
    drawAll(); updateCounts();
    logBox.innerHTML = "";
  }

  // Safer placer: avoids index errors, guarantees exactly 3*ITEMS_PER items
  function placeGroundItemsSafe(){
    if (!ground || ground.length !== N){ ground = Array.from({length:N}, _ => Array(N).fill(null)); }
    else { for (let y=0;y<N;y++) for (let x=0;x<N;x++) ground[y][x] = null; }
    const forbidden = new Set(CORNERS.map(p=>key(p.x,p.y)));
    const coords = [];
    for (let y=0;y<N;y++) for (let x=0;x<N;x++){ if (!forbidden.has(key(x,y))) coords.push({x,y}); }
    shuffle(coords);
    const items = []; for (let k=0;k<ITEMS_PER;k++) items.push('rock','paper','scissors');
    for (let i=0;i<items.length && i<coords.length; i++){ const {x,y} = coords[i]; ground[y][x] = items[i]; }
  }

  function previewAgents(){
    agents = CORNERS.map((p,i)=>({ id:i, color:COLORS[i], x:p.x, y:p.y, alive:true, inv:null, q:newQ(), episode:newEpisode() }));
    for (const a of agents){ ownership[a.y][a.x] = a.color; }
    ensureAgentEls();
    updateAgentPositions();
  }

  function ensureAgentEls(){
    if (agentEls.size === agents.length) return;
    // remove existing
    agentEls.forEach(el=>el.remove()); agentEls.clear();
    for (const a of agents){
      const el = document.createElement('div');
      el.className = `agent ${a.color}`;
      el.style.width = agentPx+"px"; el.style.height = agentPx+"px";
      el.textContent = a.inv ? EMOJI[a.inv] : '¬∑';
      boardEl.appendChild(el);
      agentEls.set(a.id, el);
    }
  }

  function respawnForNewGame(){
    agents.forEach((a,i)=>{ const p = CORNERS[i]; a.x = p.x; a.y = p.y; a.alive = true; a.inv = null; a.episode = newEpisode(); });
    ownership = Array.from({length:N}, _ => Array(N).fill(null));
    for (const a of agents){ ownership[a.y][a.x] = a.color; }
    ensureAgentEls();
    updateAgentPositions();
  }

  function drawAll(){
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        const el = cellEl(x,y);
        el.className = "cell"; el.replaceChildren();
        const own = ownership[y][x]; if (own) el.classList.add("owner", own);
        const item = ground[y][x]; if (item){ const g=document.createElement("div"); g.className="ground"; g.textContent=EMOJI[item]; el.appendChild(g); }
      }
    }
    // agents are drawn via absolute-positioned elements for smooth slide
  }

  function updateAgentPositions(){
    if (!cellCenters.length) cacheLayout();
    const dur = Math.max(60, Math.min(300, Math.round(800/stepsPerSec)));
    agentEls.forEach(el=>{ el.style.transitionDuration = `${dur}ms`; });
    for (const a of agents){
      const el = agentEls.get(a.id);
      if (!el) continue;
      if (!a.alive){ el.style.display='none'; continue; }
      el.style.display='grid';
      el.textContent = a.inv ? EMOJI[a.inv] : '¬∑';
      const [cx,cy] = cellCenters[a.y][a.x];
      el.style.left = (cx - agentPx/2) + 'px';
      el.style.top  = (cy - agentPx/2) + 'px';
    }
  }

  function updateCounts(){
    let counts = { red:0, blue:0, green:0, yellow:0 };
    for (let y=0;y<N;y++) for (let x=0;x<N;x++){ const o = ownership[y][x]; if (o) counts[o]++; }
    redCountEl.textContent = counts.red; blueCountEl.textContent = counts.blue; greenCountEl.textContent = counts.green; yellowCountEl.textContent = counts.yellow;
    return counts;
  }

  function randomStepFor(a){
    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
    const valids = dirs.filter(s=>inBounds(a.x+s.dx, a.y+s.dy));
    return valids[(Math.random()*valids.length)|0];
  }

  function pickPolicy(agent, item){
    if (!item) return "skip";
    if (Math.random() < EPSILON) return PICK_ACTIONS[(Math.random()*PICK_ACTIONS.length)|0];
    const q = agent.q[item];
    return (q.pick >= q.skip) ? "pick" : "skip";
  }

  function trendBonusFor(item){
    const total = winsByItem.rock + winsByItem.paper + winsByItem.scissors;
    if (total === 0) return 0;
    return 0.2 * (winsByItem[item] / total);
  }

  function countGround(){
    const c = { rock:0, paper:0, scissors:0, total:0 };
    for (let y=0;y<N;y++) for (let x=0;x<N;x++){
      const v = ground[y][x]; if (v){ c[v]++; c.total++; }
    }
    return c;
  }

  // Spawn one random item on a random eligible empty cell (not corner, not occupied)
  function spawnRandomItem(){
    const forbidden = new Set(CORNERS.map(p=>key(p.x,p.y)));
    const occupied = new Set(agents.filter(a=>a.alive).map(a=>key(a.x,a.y)));
    const choices = [];
    for (let y=0;y<N;y++) for (let x=0;x<N;x++){
      const k = key(x,y);
      if (ground[y][x] === null && !forbidden.has(k) && !occupied.has(k)) choices.push({x,y});
    }
    if (choices.length === 0) return false;
    const spot = choices[(Math.random()*choices.length)|0];
    const item = ITEM_LIST[(Math.random()*ITEM_LIST.length)|0];
    ground[spot.y][spot.x] = item;
    log(`Spawned ${item} at ${spot.x},${spot.y}`);
    return true;
  }
  function nextSpawnSteps(){ return 20 + ((Math.random()*11)|0); }

  // ======= Map reset preserving Q-learners =======
  function resetMapPreserveBrains(){
    if (!agents || agents.length !== 4){
      // first load or agents missing: create preview agents (fresh brains)
      initEmpty();
      placeGroundItemsSafe();
      previewAgents();
      drawAll(); cacheLayout(); updateAgentPositions();
      return;
    }
    // preserve brains, respawn at corners on a fresh map
    ground = Array.from({length:N}, _ => Array(N).fill(null));
    placeGroundItemsSafe();
    respawnForNewGame();
    drawAll(); cacheLayout(); updateAgentPositions();
    window.__t.resets++;
  }

  // convenience for Start button semantics
  function handleStartPressed(){
    if (running) return;
    if (gameOver){ resetMapPreserveBrains(); }
    startGame();
  }

  // ======= Auto Next (one game at a time): if gameOver -> New Map -> Start =======
  function autoAdvanceOneGame(){
    if (!autoNext || !autoNext.checked) return;
    if (!gameOver) return; // only after a game ends
    resetMapPreserveBrains();
    startGame();
  }

  // ======= Simulation step =======
  function step(){
    stepCount++;
    // proposed moves
    const moves = new Map();
    const targetMap = new Map();
    const prevPos = new Map();
    for (const a of agents){ if (a.alive) prevPos.set(a.id, {x:a.x,y:a.y}); }

    for (const a of agents){
      if (!a.alive) continue;
      const {dx,dy} = randomStepFor(a);
      const nx = a.x + dx, ny = a.y + dy;
      moves.set(a.id, {nx,ny});
      const k = key(nx,ny); if (!targetMap.has(k)) targetMap.set(k, []); targetMap.get(k).push(a.id);
    }

    // Head-on swap detection: if A goes to B's last cell and B goes to A's, resolve by items; both survive only if same item
    const swapLosers = new Set();
    const handled = new Set();
    for (const a of agents){
      if (!a.alive) continue;
      const ma = moves.get(a.id); if (!ma) continue;
      for (const b of agents){
        if (b.id===a.id || !b.alive) continue;
        const mb = moves.get(b.id); if (!mb) continue;
        const tag1 = `${a.id}-${b.id}`, tag2 = `${b.id}-${a.id}`;
        if (handled.has(tag1) || handled.has(tag2)) continue;
        const pa = prevPos.get(a.id), pb = prevPos.get(b.id);
        if (pa && pb && ma.nx===pb.x && ma.ny===pb.y && mb.nx===pa.x && mb.ny===pa.y){
          const ai = a.inv || null, bi = b.inv || null;
          if (ai !== bi){
            const res = rpsWinner(ai, bi);
            if (res > 0){ swapLosers.add(b.id); log(`${a.color} beats ${b.color} on head-on swap, ${(ai||"empty")} beats ${(bi||"empty")}!`); }
            else if (res < 0){ swapLosers.add(a.id); log(`${b.color} beats ${a.color} on head-on swap, ${(bi||"empty")} beats ${(ai||"empty")}!`); }
          }
          handled.add(tag1); handled.add(tag2);
        }
      }
    }

    // collisions into same cell (RPS)
    const losers = new Set(swapLosers);
    for (const [k, ids] of targetMap.entries()){
      if (ids.length <= 1) continue;
      const players = ids.map(id => agents[id]).filter(p=>p.alive && !losers.has(p.id));
      if (players.length <= 1) continue;
      const stillIn = new Set(players.map(p=>p.id));
      for (let i=0;i<players.length;i++){
        for (let j=0;j<players.length;j++){
          if (i===j) continue;
          const A = players[i], B = players[j];
          const res = rpsWinner(A.inv, B.inv);
          if (res < 0) stillIn.delete(A.id);
        }
      }
      const localLosers = players.filter(p=>!stillIn.has(p.id));
      for (const L of localLosers){
        losers.add(L.id);
        let winnerFound = players.find(W => rpsWinner(W.inv, L.inv) > 0 && stillIn.has(W.id));
        if (!winnerFound) winnerFound = players.find(W => stillIn.has(W.id)) || players[0];
        const wColor = winnerFound.color, lColor = L.color; const wItem = winnerFound.inv || "empty"; const lItem = L.inv || "empty";
        log(`${wColor} beats ${lColor}, ${wItem} beats ${lItem}!`);
      }
    }

    // move survivors, claim tiles, pick up items (Q‚Äëpolicy)
    for (const a of agents){
      if (!a.alive || losers.has(a.id)) continue;
      const mv = moves.get(a.id); if (!mv) continue;
      const prevOwned = ownership[mv.ny][mv.nx];
      a.x = mv.nx; a.y = mv.ny;
      ownership[a.y][a.x] = a.color;
      if (!prevOwned) a.episode.stepCoverReward += STEP_REWARD_NEW_TILE;

      const item = ground[a.y][a.x];
      if (item){
        const action = pickPolicy(a, item);
        const shaped = trendBonusFor(item);
        a.episode.pickups.push({ state:item, action, shaped });
        if (action === "pick"){ a.inv = item; ground[a.y][a.x] = null; }
      }
    }

    // eliminate losers
    for (const id of losers){ const a = agents[id]; if (!a.alive) continue; a.alive = false; a.inv = null; a.episode.survived = false; }

    // check win
    const counts = updateCounts();
    const aliveAgents = agents.filter(a=>a.alive);
    let winner = null, winBy = "";
    const winByTiles = aliveAgents.find(a => counts[a.color] >= CLAIM_TO_WIN);
    if (winByTiles){ winner = winByTiles; winBy = "tiles"; }
    else if (aliveAgents.length === 1){ winner = aliveAgents[0]; winBy = "last"; }

    // timed item spawn: every 20‚Äì30 steps (randomized window)
    if (--spawnIn <= 0) { spawnRandomItem(); spawnIn = nextSpawnSteps(); }

    // draw & animate
    drawAll();
    updateAgentPositions();

    if (winner){
      running = false; stopLoop(); pauseBtn.disabled = true; startBtn.disabled = false; gameOver = true;
      log(`${winner.color} wins by ${winBy}.`);
      if (winner.inv) winsByItem[winner.inv]++;
      winsByColor[winner.color]++;
      cwRed.textContent = winsByColor.red; cwBlue.textContent = winsByColor.blue; cwGreen.textContent = winsByColor.green; cwYellow.textContent = winsByColor.yellow;
      gamesEl.textContent = ++gameCount; wR.textContent = winsByItem.rock; wP.textContent = winsByItem.paper; wS.textContent = winsByItem.scissors;

      for (const a of agents){
        const ep = a.episode;
        let R = ep.stepCoverReward;
        if (a.id === winner.id){ R += (winBy === "tiles" ? WIN_REWARD_TILES : WIN_REWARD_LAST); ep.win = true; ep.winBy = winBy; }
        else if (!a.alive){ R += LOSS_REWARD; }
        for (const d of ep.pickups){
          const qsa = a.q[d.state][d.action];
          const target = R + d.shaped; // terminal target
          a.q[d.state][d.action] = (1-ALPHA)*qsa + ALPHA*target;
        }
      }

      if (autoNext.checked){ autoAdvanceOneGame(); }
    } else if (agents.every(a=>!a.alive)){
      running = false; stopLoop(); pauseBtn.disabled = true; startBtn.disabled = false; gameOver = true; log(`Draw ‚Äî no agents remain.`);
      for (const a of agents){
        const ep = a.episode; let R = ep.stepCoverReward - 0.5;
        for (const d of ep.pickups){ const qsa = a.q[d.state][d.action]; const target = R + d.shaped; a.q[d.state][d.action] = (1-ALPHA)*qsa + ALPHA*target; }
      }
      if (autoNext.checked){ autoAdvanceOneGame(); }
    }
  }

  // ======= Loop control =======
  function startGame(){$1stepCount = 0; spawnIn = nextSpawnSteps();
    running = true; startLoop();
    window.__t.starts++;
  }
  function startLoop(){ stopLoop(); stepTimer = setInterval(step, 1000/stepsPerSec); }
  function stopLoop(){ if (stepTimer){ clearInterval(stepTimer); stepTimer = null; } }

  // ======= UI =======
  resetBtn.addEventListener("click", () => {
    running = false; stopLoop(); pauseBtn.disabled = true; startBtn.disabled = false;
    resetMapPreserveBrains();
  });

  startBtn.addEventListener("click", () => { if (running) return; handleStartPressed(); });

  pauseBtn.addEventListener("click", () => {
    if (!running){ running = true; startBtn.disabled = true; pauseBtn.textContent = "Pause"; startLoop(); }
    else { running = false; stopLoop(); startBtn.disabled = false; pauseBtn.textContent = "Resume"; }
  });

  speed.addEventListener("input", e => { stepsPerSec = +e.target.value; speedVal.textContent = stepsPerSec; if (running) startLoop(); });
  eps.addEventListener("input", e => { EPSILON = +e.target.value; epsVal.textContent = EPSILON.toFixed(2); });

  // ======= Boot =======
  buildBoard();
  initEmpty();
  placeGroundItemsSafe();
  previewAgents(); // show agents BEFORE starting
  drawAll();
  cacheLayout();
  updateAgentPositions();

  // ======= Lightweight tests =======
  (function sanity(){
    const c = countGround();
    console.assert(c.rock === ITEMS_PER && c.paper === ITEMS_PER && c.scissors === ITEMS_PER, 'Each item count should equal ITEMS_PER', c);
    console.assert(cells.length === N*N, 'Board should have 64 cells', cells.length);
    console.assert(agents.length === 4, 'Should have 4 agents', agents.length);
    console.assert(typeof resetMapPreserveBrains === 'function', 'resetMapPreserveBrains exists');
    console.assert(typeof autoAdvanceOneGame === 'function', 'autoAdvanceOneGame exists');
    console.assert(CLAIM_TO_WIN === 40, 'CLAIM_TO_WIN should be 40');

    // spawn test: should increase total by 1 when space exists
    let before = countGround().total; const ok = spawnRandomItem(); let after = countGround().total;
    console.assert(!ok || after === before + 1, 'spawnRandomItem should add exactly one item when possible');

    // randomized spawn window tests
    for (let i=0;i<20;i++){ const n = nextSpawnSteps(); console.assert(n>=20 && n<=30, 'nextSpawnSteps should return 20..30'); }
    // countdown triggers spawn on step when spawnIn==1
    const before2 = countGround().total; spawnIn = 1; step(); const after2 = countGround().total;
    console.assert(after2 === before2 + 1, 'spawnIn countdown should spawn exactly one item when reaching zero');
    console.assert(spawnIn >= 20 && spawnIn <= 30, 'spawnIn should reset into 20..30 after spawn');

    // Auto Next one-shot semantics
    const prevResets = window.__t.resets, prevStarts = window.__t.starts;
    autoNext.checked = true; gameOver = true; running = false;
    autoAdvanceOneGame();
    console.assert(window.__t.resets === prevResets + 1, 'Auto Next should reset map exactly once');
    console.assert(window.__t.starts === prevStarts + 1, 'Auto Next should start game exactly once');
    console.assert(gameOver === false && running === true, 'Game should be running after auto-advance');

    // Start button semantics
    running = false; gameOver = true; // simulate ended game
    const prevResets2 = window.__t.resets, prevStarts2 = window.__t.starts;
    handleStartPressed();
    console.assert(window.__t.resets === prevResets2 + 1, 'Start should reset when gameOver');
    console.assert(window.__t.starts === prevStarts2 + 1, 'Start should start game');

    // RPS special rule tests
    console.assert(rpsWinner('rock','scissors') === 1, 'rock beats scissors');
    console.assert(rpsWinner('rock','paper') === -1, 'rock loses to paper');
    console.assert(rpsWinner('paper','rock') === 1, 'paper beats rock');
    console.assert(rpsWinner('paper','scissors') === -1, 'paper loses to scissors');
    console.assert(rpsWinner('scissors','paper') === 1, 'scissors beats paper');
    console.assert(rpsWinner('scissors','rock') === -1, 'scissors loses to rock');
    console.assert(rpsWinner('paper','paper') === 0, 'same items draw');
    console.assert(rpsWinner('rock', null) === 1, 'item beats empty');
    console.assert(rpsWinner(null, 'paper') === -1, 'empty loses to item');
  })();
})();
</script>
</body>
</html>
